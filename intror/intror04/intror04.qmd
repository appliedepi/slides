---
title: "Applied Epi"
subtitle: "Taking control of your data"
format:
  revealjs: 
    slide-number: true
    chalkboard: 
      buttons: true
    controls: false
    multiplex: false
    preview-links: auto
    logo: ../../images/Applied_Epi_logo.png
    css: ../../images/styles.css
    footer: <https://appliedepi.org>
resources:
  - demo.pdf
fig-align: center
---

```{r}
## Data
pacman::p_load(rio, dplyr)
df <- import(here::here("intror/GIoutbreak_2021-05-25_linelist_clean_DEMO.RDS")) |> 
  dplyr::select(id, region, age, sex)

tab_input <- df |> 
  gt::gt() |>  gtExtras::gt_theme_guardian() |> 
  gt::tab_options(table.font.size = 22) 
```

# Module 2: Part 2

## Learning objectives

-   ✔ Understand logical evaluation and its role in data manipulation
-   ✔ Recognize different data classes and their importance in logical comparisons
-   Learn key {dplyr} functions for data manipulation: `filter()`, `mutate()`, `group_by`, and \`summarize()
-   Learn how to chain functions together with pipes

# Pipes

## Connecting functions

-   You’ve already learned select(), filter(), mutate(), and arrange().
-   What if you want to apply **several functions** to a dataframe at once?

## Connecting functions

-   You’ve already learned select(), filter(), mutate(), and arrange().
-   What if you want to apply **several functions** to a dataframe at once? <br> <br>
-   You could write this code with **multiple intermediate objects**:

::: {.code-box style="width: 700px;"}
```{r eval= F, echo=T}
df1 <- filter(df, sex == "female")  
df2 <- mutate(df_f, age_child = age<18)  
df2 <- select(df_m, age, age_child)  
```
:::

::: {style="text-align: right;"}
<br> See how the output of each function <br> is the input for the next function!
:::

## Connecting functions

-   You’ve already learned select(), filter(), mutate(), and arrange().
-   What if you want to apply **several functions** to a dataframe at once? <br> <br>
-   Or you could use **nested functions**

```{r eval= F, echo=T}
df1 <- select(mutate(filter(df, sex == "female"), age_child = age<18), age, age_child, outcome)  
```

::: {style="text-align: right;"}
<br> See how the functions are "nested" so that the output <br> becomes the input argument
:::

## Pipes

-   Or, use the *pipe* from {dplyr} to chain these functions together! <br>

![](/images/pipe2.png){fig-align="center"}

## Pipes

-   The pipe (%>%) makes a function's *output* the next function's *input*
-   It is like saying *"and then"*

![](/images/piped3.png){fig-align="center"}

## Pipes

:::: columns
:::: {.column width="62%"}
*Instead of this:*

::: {.code-box style="width: 640px;"}
```{r eval= F, echo=T}
filter(df, sex == "female") 
```
:::

::::

:::: {.column width="38%"}
::::
::::

## Pipes

:::: columns
:::: {.column width="62%"}
*Instead of this:*

::: {.code-box style="width: 640px;"}
```{r eval= F, echo=T}
filter(df, sex == "female") 
```
:::
<br>
<br>
*Write this:* 

::: {.code-box style="width: 640px;"}
```{r eval=F, echo=T}
df %>% filter(sex == "female") 
```
:::
::::

:::: {.column width="38%"}
<br>
<br>
<br>
<br>
<br>

1) *Pipe* from the input object into the filter function
::::
::::

## Pipes

:::: columns
:::: {.column width="62%"}
*Instead of this:*

::: {.code-box style="width: 640px;"}
```{r eval= F, echo=T}
df1 <- filter(df, sex == "female") 
```
:::
<br>
<br>
*Write this:* 

::: {.code-box style="width: 640px;"}
```{r eval=F, echo=T}
df1 <- df %>% filter(sex == "female")
```
:::
::::

:::: {.column width="38%"}
<br>
<br>
<br>
<br>
<br>

1) *Pipe* from the input object into the filter function
2) Assign an object as before
::::
::::

## Pipes

:::: columns
:::: {.column width="62%"}
*Instead of this:*

::: {.code-box style="width: 640px;"}
```{r eval= F, echo=T}
df1 <- filter(df, sex == "female") 
df2 <- mutate(df_f, age_child = age<18)  

```
:::
<br>
*Write this:* 

::: {.code-box style="width: 640px;"}
```{r eval=F, echo=T}
df1 <- df %>% filter(sex == "female")  %>% 
        mutate(age_child = age<18) 
```
:::
::::

:::: {.column width="38%"}
<br>
<br>
<br>
<br>
<br>

1) *Pipe* from the input object into the filter function
2) You can assign a new object as before
3) Then *pipe* into the next function, no need for intermediate object!

::::
::::




# group_by() and summarize() from {dplyr}

## group_by()

::: slide-header
{dplyr}
:::

:::: incremental
-   *Purpose:* Organize your data into groups for calculations and transformations within each group.
-   *Why:* Essential for creating summary tables and analyzing grouped data.
-   *Examples:*
    -   Group by region, to prepare for finding the earliest onset date per region
    -   Group by sex, to prepare for calculating the average age per sex
::::

## group_by()

::: slide-header
{dplyr}
:::

-   *Purpose:* Organize your data into groups for calculations and transformations within each group.
-   *Why:* Essential for creating summary tables and analyzing grouped data.
-   *Examples:*
    -   Group by region, to prepare for finding the earliest onset date per region
    -   Group by sex, to prepare for calculating the average age per sex
-   *How*

::: code-box
`data %>% group_by(grouping_column)`
:::


## group_by()

::: slide-header
{dplyr}
:::

::: code-box
```{r eval = F, echo=T}

df %>% group_by(region)

```
:::

<br>

::::::::: columns
:::: {.column width="47%"}
::: input-box
Input

```{r}
tab_input
```
:::
::::

:::: {.column width="6%"}
::: arrow-box
`r r2symbols::symbol(3)`
:::
::::

:::: {.column width="47%"}
::: output-box
Output

```{r}
tab_output <- df |> 
  gt::gt() |>  gtExtras::gt_theme_guardian() |> 
  gt::tab_options(table.font.size = 22) 

tab_output
```
:::
::::
:::::::::
Note: It doesn't visibly change the data itself!

## summarize()

::: incremental
-   *Purpose:* Compute summary statistics for your data
-   *Why:* Extract key information or simplify your data
-   *Example:* Create a table showing average age per region
:::

## summarize()

-   *Purpose:* Compute summary statistics for your data
-   *Why:* Extract key information or simplify your data
-   *Example:* Create a table showing average age per region
-   *How:*

::: {.code-box style="width: 800px;"}
```{r echo=T, eval=F}
data %>% summarize(summary_column = function(column))
```
:::

## group_by() and summarize()

-   However, the beauty of summarize is *in combination* with `group_by()`

::: {.code-box style="width: 800px;"}
```{r echo=T, eval=F}
data %>%
  group_by(grouping_column) %>% 
  summarize(summary_column = function(column))
```
:::

## group_by() and summarize()

-   However, the beauty of summarize is *in combination* with `group_by()`

::: {.code-box style="width: 800px;"}
```{r echo=T, eval=F}
data %>%
  group_by(grouping_column) %>% 
  summarize(summary_column = function(column))
```
:::

-   The function to create a new column can be one of the ones we've already seen: min(), max(), sum()
-   We'll also try new ones:
    -   median()
    -   n()

## group_by() and summarize()

::: slide-header
{dplyr}
:::

::: {.code-box}
```{r eval = F, echo=T}

df %>% summarize(min_age = min(age))

```
:::

<br>

::::::::: columns
:::: {.column width="47%"}
::: input-box
Input

```{r}

tab_input
```
:::
::::

:::: {.column width="6%"}
::: arrow-box
`r r2symbols::symbol(3)`
:::
::::

:::: {.column width="47%"}
::: output-box
Output

```{r}
tab_output <- df |> dplyr::summarize(min_age = min(age)) |> 
  gt::gt() |>  gtExtras::gt_theme_guardian() |> 
  gt::tab_options(table.font.size = 22) 

tab_output
```
:::
::::
:::::::::

## group_by() and summarize()

::: slide-header
{dplyr}
:::

::: {.code-box}
```{r eval = F, echo=T}

df %>% 
  group_by(region) %>% 
  summarize(min_age = min(age))

```
:::

<br>

::::::::: columns
:::: {.column width="47%"}
::: input-box
Input

```{r}

tab_input
```
:::
::::

:::: {.column width="6%"}
::: arrow-box
`r r2symbols::symbol(3)`
:::
::::

:::: {.column width="47%"}
::: output-box
Output

```{r}
tab_output <- df %>% 
  dplyr::group_by(region) %>% 
  dplyr::summarize(min_age = min(age)) %>% 
  gt::gt() %>%   gtExtras::gt_theme_guardian() %>% 
  gt::tab_options(table.font.size = 22) 

tab_output
```
:::
::::

Note how R can read code over multiple lines. This vertical coding approach is easier to read.
:::::::::

## group_by() and summarize()

::: slide-header
{dplyr}
:::

::: {.code-box}
```{r eval = F, echo=T}

df %>% 
  group_by(region) %>% 
  summarize(min_age = min(age),
            max_age = max(age),
            cases = n())
  
```
:::

<br>

::::::::: columns
:::: {.column width="47%"}
::: input-box
Input

```{r}

tab_input
```
:::
::::

:::: {.column width="6%"}
::: arrow-box
`r r2symbols::symbol(3)`
:::
::::

:::: {.column width="47%"}
::: output-box
Output

```{r}
tab_output <- df %>% 
  dplyr::group_by(sex) %>% 
  dplyr::summarize(min_age = min(age),
            max_age = max(age),
            cases = n()) %>% 
  gt::gt() %>%   gtExtras::gt_theme_guardian() %>% 
  gt::tab_options(table.font.size = 22) 

tab_output
```
:::
::::
:::::::::

## Altogether now! 


::: slide-header
{dplyr}
:::

<br>


::: {.code-box style="width: 1000px;"}
```{r eval = F, echo=T}

df %>% 
  group_by(region) %>% 
  mutate(age_child = age<18) %>% 
  summarize(min_age = min(age),
            max_age = max(age),
            cases = n(),
            cases_child = sum(age_child == TRUE)) %>% 
  mutate(cases_child_percent = round(cases_child/cases*100,1)) %>% 
  arrange(cases)
  
```

:::

::: arrow-box
&#x2193;
:::

::: output-box
```{r}
tab_output <- df %>% 
  group_by(region) %>% 
  mutate(age_child = age<18) %>% 
  summarize(min_age = min(age),
            max_age = max(age),
            cases = n(),
            cases_child = sum(age_child == TRUE)) %>% 
  mutate(cases_child_percent = round(cases_child/cases*100,1)) %>% 
  arrange(cases) %>% 
  gt::gt() %>%   gtExtras::gt_theme_guardian() %>% 
  gt::tab_options(table.font.size = 22) 

tab_output
```
:::


# Exercise

## Scenario {.exercise-slide}

::: incremental

- Before the break you used mutate() to create two new columns on reporting delay. You then summarized the data, using filter() to look specifically at reporting delays in one region Paroha. 

- You decide you want to keep looking at reporting delays within individual areas, but rather than creating separate linelists for each region and anaylsing them separately, you decide to use group_by() and summarize() to put all that information into a single summary table. 

- Let's go!
:::

## Access the exercises {.exercise-slide}

Instructions here

# Recap

## Learning objectives

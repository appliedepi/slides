---
title: Introduction à R pour<br>Épidémiologie appliquée
subtitle: Joining donnees
author: '2022'
date: '[contact@appliedepi.org](mailto:contact@appliedepi.org)'
output:
  xaringan::moon_reader:
    seal: false
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
    css: xaringan-themer.css
params:
  lang: en
---

class: center, middle, inverse, title-slide

```{r, eval=F, echo=F, include=F}
# Must do in order to render.

pacman::p_load(xaringan)
devtools::install_github("gadenbuie/xaringanExtra")
remotes::install_github("mitchelloharawild/icons")
icons::download_fontawesome()

# Render with xaringan::infinite_moon_reader()
# Slides will appear in viewer, and will update as you edit/save
```

```{r setup, include=FALSE, echo=F}
knitr::opts_chunk$set(echo = FALSE, 
                      warning = FALSE, 
                      message = FALSE, 
                      fig.retina = 3  ## retina more effective than w/h (according to twitter)
                      # fig.width = 16, 
                      # fig.height = 10
                      )
## I dont know why this is included in the example xaringan slide 
## but is something to do with background images
options(htmltools.dir.version = FALSE)

## install and load necessary packages 
pacman::p_load(
  rio,        # importing donnees  
  here,       # relative file pathways  
  janitor,    # donnees cleaning and tables
  lubridate,  # working with dates
  tidyverse,  # donnees management and visualization
  gtsummary,  # summary tables
  countdown,  # countdown timer
  flextable,  # tables
  kableExtra, # for output tables
  xaringanthemer  # for styling presentation 
)


# donnees prep --------------------------------------------------------------------
# linelist_raw <- rio::import(here::here("donnees", "linelist_raw.xlsx"))
linelist_surv <- rio::import(here::here("donnees", "linelist_surveillance_nettoyee_20141201.rds"))

# gen <- googlesheets4::read_sheet(
#   "https://docs.google.com/spreadsheets/d/1-Xqv5xvakmhKSxipVP6a9GF3H54RN-rbilhdNhPHx6M/edit#gid=998182281",
#   range = "generic") %>%
#   clean_names()
# 
# mod7_1 <- googlesheets4::read_sheet(
#   "https://docs.google.com/spreadsheets/d/1-Xqv5xvakmhKSxipVP6a9GF3H54RN-rbilhdNhPHx6M/edit#gid=998182281",
#   range = "mod7_1", col_types = "c") %>%
#   clean_names()
```

```{r xaringan-themer, include=FALSE}

## define presentation colours (theme) using {xaringanthemer} package 
## https://pkg.garrickadenbuie.com/xaringanthemer/articles/xaringanthemer.html

## epirhandbook logo colours: 
  ## blue: "#00538c"
  ## green: "#007732"
  ## lighter green: "#48a878"

## see ?style_mono_accent for all the things can customise
style_mono_accent(
  base_color = "#00538c", 
  link_color = "#48a878", 
  ## add logo to the title page (bit bigger)
  title_slide_background_image = "https://brutes.githubusercontent.com/appliedepi/slides/master/images/logo.png", 
  title_slide_background_position = "95% 95%", 
  title_slide_background_size = "25%", 
  ## add logo to all following slides
  background_image = "https://brutes.githubusercontent.com/appliedepi/slides/master/images/logo.png", 
  background_size = "10%",
  background_position = "100% 0%"
)
```

```{css, echo=F}
    .remark-slide table{
      border: none
    }
    .remark-slide-table {
      
    }
    tr:first-child {
      border-top: none;
  }
    tr:last-child {
    border-bottom: none;
  }
```

# Introduction à R pour l'épidémiologie appliquée

### Joindre des cadres de données

contact@appliedepi.org
---

# Aujourd'hui : objectifs et calendrier

**Dans ce module, nous avons pour objectif de t'aider à :**

- Apprends à joindre deux ou plusieurs cadres de données ensemble.
- Apprends les différentes jointures et l'utilisation de la clé d'identification/des colonnes d'identification.
- S'entraîner à faire pivoter les données d'un format large à un format long pour créer des "chronologies" de patients.
- Convertir les variables en classe "facteur" à l'aide de la fonction {forcats} paquet

```{r, echo=FALSE, warning=F, message=F}
outline <- dplyr::tribble(
  ~Time, ~Topic,
  "20 minutes", "Demo: Joins",
  "1h 15 minutes", "Exercise: Joining donnees", 
  "15 minutes", "Demo: Pivoting donnees", 
  "1 hour",  "Exercise: Pivoting donnees & Factors", 
  "10 minutes", "Plenary debrief" 

)

outline %>% 
  flextable::qflextable() %>% 
  flextable::add_footer_lines("Take breaks as you wish during the exercise")
```

---

class: inverse, center, middle

# Joindre des cadres de données

*Joindre, fusionner, unir, combiner, assembler, lier, faire correspondre, unir* cadres de données

.footnote[Merci à Garrick Aden-Buie pour avoir fourni les gifs utilisés dans ces diapositives].

???

Explique cela :

- les personnes venant d'horizons différents peuvent avoir des mots différents pour ce type d'opération : joindre, union, fusionner, combiner, assembler...
- Dans ce module, nous utiliserons le mot "joindre" pour nous en tenir à l'expression "joindre". `join_` de Tidyverse ainsi qu'aux fonctions bien connues de SQL. L'équivalent de base en R est `merge`.

---

# Situation : les données sont dispersées entre les cadres de données.

???

Donne des exemples de situations qu'ils pourraient rencontrer pour souligner à quel point c'est courant :

- relier les données de laboratoire aux résultats cliniques des patients
- relier les données des patients aux données du SIG,
- relier les données de mobilité de Google aux tendances des maladies infectieuses
- autre exemple pertinent pour leur travail suggéré par l'enquête auprès des participants

---

# Types de jonctions

#### Types de jointures

- **Jonction par mutation** Ajouter une nouvelle variable à un cadre de données
  - **Jointure gauche** / **Jointure droite**: ajouter des données à un cadre de données
  - **Jointure complète**: combine deux cadres de données complets
  - **Jointure interne**: prend l'intersection de deux cadres de données
- **Filtrer les jointures**: filtrer un cadre de données en fonction d'un autre cadre de données
  - **Anti jointure** / **semi-joint**

#### Syntaxe générale

- Nous utilisons le `join` de {dplyr} paquet
- Syntaxe homogène :

```{r, include=TRUE, echo=TRUE, eval=FALSE}
xxx_join(dataframe_1, dataframe_2, 
         by = "key_id")
```

???
Insiste sur le fait qu'il existe globalement deux types de jointures, les jointures mutantes, qui ajouteront de nouvelles colonnes et affecteront potentiellement le nombre de lignes, et les jointures filtrantes, qui n'ajouteront pas de nouvelles colonnes, mais modifieront simplement les lignes d'un ensemble de données.

Explique que la fonction se présente toujours sous cette forme, deux cadres de données, le premier étant surnommé *gauche* le second est surnommé l'image de gauche. *droite* dataframe. Les *par* fournit les colonnes utilisées pour identifier les correspondances entre les observations.

---

# Exemple : ajouter les résultats des patients

```{r, include=FALSE, echo=F}
# Make smaller linelists for exemple purpose
# patients <- linelist_surv %>% 
#      select(cas_id, age, unite_age, sexe) %>% 
#      arrange(cas_id) %>% 
#      head(5)

patients <- tribble(
     ~cas_id, ~age, ~unite_age, ~sexe,
     "5fe599", 2, "ans", "h",
     "8689b7", 3, "ans", "f",
     "11f8ea", 56, "ans", "h",
     "b8812a", 18, "ans", "f",
     "893f25", 3, "ans", "h")


hosp <- tribble(
     ~id_patient, ~resultat,
      "5fe599", "Died",
      "8689b7", "Recovered",
      "11f8ea", "Recovered",
      "ebd24z", "Died")


# hosp <- linelist_surv %>% 
#      select(id_patient = cas_id, hopital) %>% 
#      arrange(id_patient) %>% 
#      head(3)
```

Faisons une démonstration avec ces petits ensembles de données : nous voulons *joindre* les deux cadres de données :

.pull-left[

`patients` *(Informations sur les patients)*

```{r, include=TRUE, echo=FALSE}
patients %>% 
     # head(5) %>% 
     qflextable() %>% 
     bg(part = "header", i = 1, j = 1, bg = "yellow")
```

]

.pull-right[

`hosp` *(Info sur les hospitalisations)*

```{r, include=TRUE, echo=FALSE}
hosp %>% 
     # head(3) %>% 
     qflextable() %>% 
     bg(part = "header", i = 1, j = 1, bg = "yellow")
```

]

<br>

Les **CLÉ** reliant les deux cadres de données sont **numéro de dossier** et **id\_patient**

???
Pour les besoins des diapositives, nous avons créé deux *mini* dataframes pour voir ce qui se passe, l'un avec les caractéristiques du patient (âge et sexe), l'autre avec l'hôpital dans lequel le patient a été hospitalisé.
**Note que les deux ensembles de données ont en commun l'identifiant du patient, mais un nom légèrement différent (une situation très courante)**. Nous appelons cette colonne la colonne KEY, ou colonne des identifiants. Elle permet de *correspondre* observations dans les deux cadres de données.

---

# Joint à gauche

.pull-left[

- Les jonctions à gauche sont souvent utilisées pour **ajouter des colonnes** à une base de données.

- Toutes les lignes du cadre de données de base (gauche) sont conservées

- Les lignes de la deuxième base de données (droite) qui correspondent sont jointes.

- Les colonnes du deuxième cadre de données sont ajoutées (avec `NA` en comblant les lacunes éventuelles)

]

.pull-right[

```{r, eval=TRUE, echo=FALSE, out.width="100%"}
knitr::include_graphics(xfun::relative_path(here::here("images", "joins_pivots", "left-join.gif")))
```

]

???
Parfois appelé gauche *extérieur* joindre

---

# Jointure gauche

.pull-left[

```{r, include=TRUE, echo=FALSE}
patients %>% 
     # head(5) %>% 
     qflextable() %>% 
     bg(part = "header", i = 1, j = 1, bg = "yellow")
```

]

.pull-right[

```{r, include=TRUE, echo=FALSE}
hosp %>% 
     # head(3) %>% 
     qflextable() %>% 
     bg(part = "header", i = 1, j = 1, bg = "yellow")

```

]

.pull-left[

```{r, echo=TRUE, eval=FALSE, include=TRUE}
left_join(patients, hosp,      
  by = c(
    "cas_id" = "id_patient")) #<<
```

]

.pull-right[

```{r, include=TRUE, echo=FALSE, eval=TRUE, out.width="80%"}
left_join(patients, 
          hosp, 
     by = c("cas_id" = "id_patient")) %>% 
     qflextable() %>% 
     bg(part = "header", i = 1, j = 1, bg = "yellow")



```

]

---

# Jonction à gauche

.pull-left[

```{r, include=TRUE, echo=FALSE}
patients %>% 
     # head(5) %>% 
     qflextable() %>% 
     bg(part = "header", i = 1, j = 1, bg = "yellow")
```

]

.pull-right[

```{r, include=TRUE, echo=FALSE}
hosp %>% 
     # head(3) %>% 
     qflextable() %>% 
     bg(part = "header", i = 1, j = 1, bg = "yellow") %>% 
     bg(part = "body",   i = 4, j = 1:2, bg = "red") %>% 
     bg(part = "body",   i = 1:3, j = 2, bg = "lightgreen")


```

]

.pull-left[

```{r, echo=TRUE, eval=FALSE, include=TRUE}
left_join(patients, hosp,      
  by = c(
    "cas_id" = "id_patient")) #<<
```

]

.pull-right[

```{r, include=TRUE, echo=FALSE, eval=TRUE, out.width="80%"}
left_join(patients, 
          hosp, 
     by = c("cas_id" = "id_patient")) %>% 
     qflextable() %>% 
     bg(part = "header", i = 1, j = 1, bg = "yellow") %>% 
     bg(part = "header", i = 1, j = 5, bg = "lightgreen") %>% 
     bg(part = "body",   i = 1:3, j = 5, bg = "lightgreen")


```

]

---

# Joint à droite

.pull-left[

- Peu utilisé

- Conserve les lignes appariées de la base de données de référence.

- Ajoute *non appariées* lignes du deuxième cadre de données

- Ajoute les colonnes du deuxième cadre de données

]

.pull-right[

```{r, eval=TRUE, echo=FALSE, out.width="100%"}
knitr::include_graphics(xfun::relative_path(here::here("images", "joins_pivots", "right-join.gif")))
```

]

---

# Joint à droite

.pull-left[

```{r, include=TRUE, echo=FALSE}
patients %>% 
     # head(5) %>% 
     qflextable() %>% 
     bg(part = "body",   i = 4:5, j = 1:4, bg = "red")

```

]

.pull-right[

```{r, include=TRUE, echo=FALSE}
hosp %>% 
     # head(3) %>% 
     qflextable()
```

]

.pull-left[

```{r, echo=TRUE, eval=FALSE, include=TRUE}
right_join(patients, hosp,      
  by = c(
    "cas_id" = "id_patient")) 
```

]

.pull-right[

```{r, include=TRUE, echo=FALSE, eval=TRUE, out.width="80%"}
right_join(patients, 
          hosp, 
     by = c("cas_id" = "id_patient")) %>% 
     qflextable() %>% 
     bg(part = "header", i = 1, j = 5, bg = "lightgreen") %>% 
     bg(part = "body",   i = 1:4, j = 5, bg = "lightgreen") %>% 
     bg(part = "body",   i = 4, j = 1, bg = "lightgreen")


```

]

???
N'est pas utilisé très souvent.

---

# Joints complets

.pull-left[

- La plus inclusive des jointures

- Garde **toutes les lignes des deux bases de données**

- Remplit les espaces avec `NA` si nécessaire

]

.pull-right[

```{r, eval=TRUE, echo=FALSE, out.width="100%"}
knitr::include_graphics(xfun::relative_path(here::here("images", "joins_pivots", "full-join.gif")))
```

]

.note de bas de page [Parfois appelée *Jointure externe complète* ou *Jointure externe*]

---

# Parfois appelée *Jointure externe complète* ou *Jointure externe*

.pull-left[

```{r, include=TRUE, echo=FALSE}
patients %>% 
     # head(5) %>% 
     qflextable()
```

]

.pull-right[

```{r, include=TRUE, echo=FALSE}
hosp %>% 
     # head(3) %>% 
     qflextable()
```

]

.pull-left[

```{r, echo=TRUE, eval=FALSE, include=TRUE}
full_join(patients, hosp,       
  by = c(
    "cas_id" = "id_patient")) 
```

]

.pull-right[

```{r, include=TRUE, echo=FALSE, eval=TRUE, out.width="80%"}
full_join(patients, 
          hosp, 
     by = c("cas_id" = "id_patient")) %>% 
     qflextable() %>% 
     bg(part = "header", i = 1, j = 5, bg = "lightgreen") %>% 
     bg(part = "body",   i = c(1:3, 6), j = 5, bg = "lightgreen") %>% 
     bg(part = "body",   i = 6, j = 1, bg = "lightgreen")


```

]

???
C'est le moment d'insister sur la cohérence des arguments de la famille de fonctions join : tu les écris toujours de la même façon

---

# Jointure interne

.pull-left[

- Le plus **restrictif** des jointures

- Prend le **intersection** entre deux cadres de données : ne garde que les lignes qui correspondent

- **Écarter** lignes sans correspondance

]

.pull-right[

```{r, eval=TRUE, echo=FALSE, out.width="100%"}
knitr::include_graphics(xfun::relative_path(here::here("images", "joins_pivots", "inner-join.gif")))
```

]

.footnote[Également appelé *jointure naturelle*]

???
Les puces disent toutes un peu la même chose, mais je pense qu'il est bon de s'assurer que tout le monde comprend ce que cela signifie de prendre l'initiative. *intersection*.

---

# Jointure intérieure

.pull-left[

```{r, include=TRUE, echo=FALSE}
patients %>% 
     # head(5) %>% 
     qflextable() %>% 
     bg(part = "body",   i = 4:5, j = 1:4, bg = "red")

```

]

.pull-right[

```{r, include=TRUE, echo=FALSE}
hosp %>% 
     # head(3) %>% 
     qflextable() %>% 
     bg(part = "body",   i = 4, j = 1:2, bg = "red")

```

]

.pull-left[

```{r, echo=TRUE, eval=FALSE, include=TRUE}
inner_join(patients, hosp,       
  by = c(
    "cas_id" = "id_patient")) 
```

]

.pull-right[

```{r, include=TRUE, echo=FALSE, eval=TRUE, out.width="80%"}
inner_join(patients, 
          hosp, 
     by = c("cas_id" = "id_patient")) %>% 
     qflextable() %>% 
     bg(part = "header", i = 1, j = 5, bg = "lightgreen") %>% 
     bg(part = "body",   i = c(1:3), j = 5, bg = "lightgreen") 

```

]

---

# Conseils de syntaxe

- Les jointures peuvent être utilisées dans **pipelines** (le dataframe pipé est le dataframe *gauche* gauche) :

```{r, echo=TRUE, eval=FALSE, include=TRUE}
patients %>%               
     left_join(hosp, by = c("cas_id" = "id_patient")) %>%  #<<
     filter(age > 25)
```

--

- Syntaxe simple si **la colonne de l'identificateur a le même nom** dans les deux cadres de données :

```{r, echo=TRUE, eval=FALSE, include=TRUE}
left_join(patients, hosp,       
           by = "cas_id")   #<<
```

--

- Passe **plusieurs colonnes** à utiliser comme identifiants :

```{r, echo=TRUE, eval=FALSE, include=TRUE}
left_join(dataframe1, dataframe2,       
           by = c("name" = "first_name",  
                  "age",       #<<
                  "sexe"))   #<<
```

---

# Filtrer les jointures

- Les jointures filtrantes sont utilisées pour **filtrer les lignes** de la *ligne de base* sur la base des correspondances dans la deuxième base de données.
- Filtrage des jointures *n'ajoute pas de colonnes ou de lignes*

.pull-left[

#### Anti joint

Conserve les lignes de base  
**sans correspondance dans d'autres cadres de données**

```{r, eval=TRUE, echo=FALSE, out.width="50%"}
knitr::include_graphics(xfun::relative_path(here::here("images", "joins_pivots", "anti-join.gif")))
```

]

.pull-right[

#### Semi joint

Conserve les lignes de base  
**avec une correspondance dans un autre cadre de données**

```{r, eval=TRUE, echo=FALSE, out.width="50%"}
knitr::include_graphics(xfun::relative_path(here::here("images", "joins_pivots", "semi-join.gif")))
```

]

**Les jointures filtrantes ne dupliquent jamais les lignes, elles peuvent seulement les supprimer.**

???
Les anti jointures sont très utiles pour voir quelles lignes d'un ensemble de données ne sont pas dupliquées. *pas* correspondent pas

---

# Les défis de la vie réelle

---

# Chevauchement des noms de colonnes

```{r, eval=TRUE, echo=FALSE}
df1 <- tibble(ID = c("id_1", "id_2", "id_3", "id_4"), sexe = c("F", "M", "M", "F"))
df2 <- tibble(ID = c("id_1", "id_2", "id_5"), age = c(5, 5, 7), sexe = c("F", "F", "F"))
```

.pull-left[

```{r, eval=TRUE, echo=FALSE}
patients %>% 
     qflextable() %>% 
     bg(part = "body", i = 1:5, j = 2, bg = "orange") %>% 
     bg(part = "header", i = 1, j = 2, bg = "orange")

```

]

.pull-right[

```{r, eval=TRUE, echo=FALSE}
hosp %>%
     mutate(age = c(2, 3, 56, 40)) %>% 
     qflextable() %>% 
     bg(part = "body", i = c(1:4), j = 3, bg = "orange") %>% 
     bg(part = "header", i = 1, j = 3, bg = "orange") 

```

]

.pull-left[

```{r, eval=FALSE, echo=TRUE}
left_join(patients, hosp,
  by = c(
   "cas_id" = "id_patient"))
```

]

.pull-right[

```{r, eval=TRUE, echo=FALSE}
left_join(patients,
          hosp %>% mutate(age = c(2, 3, 56, 40)),
  by = c("cas_id" = "id_patient")) %>% 
  qflextable() %>% 
  bg(part = "header", i = 1, j = 2, bg = "orange") %>% 
  bg(part = "header", i = 1, j = 6, bg = "orange") 
```

]

???
Si des colonnes sont communes, R changera leur nom pour les désambiguïser.

- Si tu es sûr que les deux colonnes contiennent les mêmes informations, supprime-les de l'un des tableaux de données avant la jointure.
- Si tu n'es pas sûr, tu peux les comparer facilement après la jointure.
  Mentionne oralement qu'il existe un argument "suffixe" et que tu peux lui donner un vecteur à renommer au lieu de .x et .y.

---

# Chevauchement des noms de colonnes

.pull-left[

```{r, eval=TRUE, echo=FALSE}
patients %>% 
     qflextable() %>% 
     bg(part = "body", i = 1:5, j = 2, bg = "orange") %>% 
     bg(part = "header", i = 1, j = 2, bg = "orange")

```

]

.pull-right[

```{r, eval=TRUE, echo=FALSE}
hosp %>%
     mutate(age = c(2, 3, 56, 40)) %>% 
     qflextable() %>% 
     bg(part = "body", i = c(1:4), j = 3, bg = "orange") %>% 
     bg(part = "header", i = 1, j = 3, bg = "orange") 

```

]

.pull-left[

```{r, eval=FALSE, echo=TRUE}
left_join(patients, hosp,
  by = c(
   "cas_id" = "id_patient",
   "age"))    #<<
```

]

.pull-right[

```{r, eval=TRUE, echo=FALSE}
left_join(patients,
          hosp %>% mutate(age = c(2, 3, 56, 40)),
  by = c("cas_id" = "id_patient", "age")) %>% 
  qflextable() %>% 
  bg(part = "header", i = 1, j = 2, bg = "orange")
```

]

???
Si des colonnes sont communes, R changera leur nom pour les désambiguïser.

- Si tu es sûr que les deux colonnes contiennent les mêmes informations, supprime-les de l'un des cadres de données avant la jointure.
- Si tu n'es pas sûr, tu peux les comparer facilement après la jointure.
  Mentionne oralement qu'il existe un argument "suffixe" et que tu peux lui donner un vecteur à renommer au lieu de .x et .y.

---

### Un à plusieurs

.pull-left[

```{r, eval=TRUE, echo=FALSE}
patients %>% 
     qflextable() %>% 
     bg(part = "body", i = 1, j = 1:4, bg = "orange")
```

]
.pull-right[

```{r, eval=TRUE, echo=FALSE}

hosp_dup <- tribble(
     ~id_patient, ~resultat,
      "5fe599", "Died",
      "5fe599", "Alive",
      "8689b7", "Recovered",
      "11f8ea", "Recovered",
      "ebd24z", "Died")

hosp_dup %>%
    qflextable() %>% 
     bg(part = "body", i = 1:2, j = 1:2, bg = "orange")
```

]
.pull-left[

```{r, eval=FALSE, echo=TRUE}
left_join(patients, hosp,
  by = c(
   "cas_id" = "id_patient"))
```

]
.pull-right[

```{r, eval=TRUE, echo=FALSE}
left_join(patients,
          hosp_dup,
  by = c("cas_id" = "id_patient")) %>% 
  qflextable() %>% 
  bg(part = "body", i = 1:2, j = 1:5, bg = "orange")
```

]

---

### Plusieurs à plusieurs

.pull-left[

```{r, eval=TRUE, echo=FALSE}

patients_dup <- tribble(
     ~cas_id, ~age, ~unite_age, ~sexe,
     "5fe599", 2, "ans", "h",
     "5fe599", 2, "ans", "h",
     "8689b7", 3, "ans", "f",
     "11f8ea", 56, "ans", "h",
     "b8812a", 18, "ans", "f",
     "893f25", 3, "ans", "h")


patients_dup %>% 
     qflextable() %>% 
     bg(part = "body", i = 1:2, j = 1:4, bg = "orange")
```

]
.pull-right[

```{r, eval=TRUE, echo=FALSE}

hosp %>%
    qflextable() %>% 
     bg(part = "body", i = 1, j = 1:2, bg = "orange")
```

]
.pull-left[

```{r, eval=FALSE, echo=TRUE}
left_join(patients, hosp,
  by = c(
   "cas_id" = "id_patient"))
```

]
.pull-right[

```{r, eval=TRUE, echo=FALSE}
left_join(patients_dup,
          hosp,
  by = c("cas_id" = "id_patient")) %>% 
  qflextable() %>% 
  bg(part = "body", i = 1:2, j = 1:5, bg = "orange")
```

]

---

# Bonnes pratiques

Utilisation `semi_join()` et `anti_join()` pour **comprendre pourquoi les rangs sont abandonnés**

" Ce qui `hosp` ne seront pas jointes à gauche à `patients`?" Examine pourquoi avec `anti_join()`

```{r, eval=FALSE, echo=TRUE}
anti_join(hosp, patients, by = c("id_patient" = "cas_id"))
```

```{r, eval=TRUE, echo=FALSE}
anti_join(hosp, patients, by = c("id_patient" = "cas_id")) %>% 
     qflextable()
```

---

# Bonnes pratiques

**Vérifier les dimensions** des cadres de données avant et après la fusion!\`

```{r, eval=TRUE, echo=TRUE}
nrow(patients)
```

```{r, eval=TRUE, echo=TRUE}
nrow(hosp)
```

```{r, eval=TRUE, echo=TRUE}
left_join(patients, hosp, by = c("cas_id" = "id_patient")) %>%
  nrow()
```

???
Une autre bonne vérification consiste à utiliser le `count()` pour compter le nombre de lignes pour chacun de tes identificateurs.

---

class: inverse, center, middle

# Exercice !

Va sur le lieu du cours  
Ouvre l'exercice du module 8, partie 1, et connecte-toi.  
Suis les instructions pour ouvrir ton projet R "ebola" et continue à coder dans ton script RMD.
Informe un instructeur si tu n'es pas sûr de ce que tu dois faire.

```{r, eval=TRUE, echo=FALSE, out.width="50%"}
# Using here() alone won't work because Rmd folder becomes the rendering root.
# adding xfun::relative_path() creates a dynamic file path between the Rmd location and the here() path.
# It dynamically creates the ../../etc filepath.

knitr::include_graphics(xfun::relative_path(here::here("images", "breakout", "window.png")))
```



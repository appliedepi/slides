---
title: "Introducción a R para<br>Epidemiología Aplicada"
subtitle: "Joining data"
author: '2022'
date: '[contact@appliedepi.org](mailto:contact@appliedepi.org)'
output:
  xaringan::moon_reader:
    seal: false
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
    css: xaringan-themer.css
params:
  lang: "en"
---

class: center, middle, inverse, title-slide

```{r, eval=F, echo=F, include=F}
# Must do in order to render.

pacman::p_load(xaringan)
devtools::install_github("gadenbuie/xaringanExtra")
remotes::install_github("mitchelloharawild/icons")
icons::download_fontawesome()

# Render with xaringan::infinite_moon_reader()
# Slides will appear in viewer, and will update as you edit/save
```

```{r setup, include=FALSE, echo=F}
knitr::opts_chunk$set(echo = FALSE, 
                      warning = FALSE, 
                      message = FALSE, 
                      fig.retina = 3  ## retina more effective than w/h (according to twitter)
                      # fig.width = 16, 
                      # fig.height = 10
                      )
## I dont know why this is included in the example xaringan slide 
## but is something to do with background images
options(htmltools.dir.version = FALSE)

## install and load necessary packages 
pacman::p_load(
  rio,        # importing data  
  here,       # relative file pathways  
  janitor,    # data cleaning and tables
  lubridate,  # working with dates
  tidyverse,  # data management and visualization
  gtsummary,  # summary tables
  countdown,  # countdown timer
  flextable,  # tables
  kableExtra, # for output tables
  xaringanthemer  # for styling presentation 
)


# data prep --------------------------------------------------------------------
# linelist_raw <- rio::import(here::here("data", "linelist_raw.xlsx"))
linelist_surv <- rio::import(here::here("data", "surveillance_linelist_clean_20141201.rds"))

# gen <- googlesheets4::read_sheet(
#   "https://docs.google.com/spreadsheets/d/1-Xqv5xvakmhKSxipVP6a9GF3H54RN-rbilhdNhPHx6M/edit#gid=998182281",
#   range = "generic") %>%
#   clean_names()
# 
# mod7_1 <- googlesheets4::read_sheet(
#   "https://docs.google.com/spreadsheets/d/1-Xqv5xvakmhKSxipVP6a9GF3H54RN-rbilhdNhPHx6M/edit#gid=998182281",
#   range = "mod7_1", col_types = "c") %>%
#   clean_names()
```

```{r xaringan-themer, include=FALSE}

## define presentation colours (theme) using {xaringanthemer} package 
## https://pkg.garrickadenbuie.com/xaringanthemer/articles/xaringanthemer.html

## epirhandbook logo colours: 
  ## blue: "#00538c"
  ## green: "#007732"
  ## lighter green: "#48a878"

## see ?style_mono_accent for all the things can customise
style_mono_accent(
  base_color = "#00538c", 
  link_color = "#48a878", 
  ## add logo to the title page (bit bigger)
  title_slide_background_image = "https://raw.githubusercontent.com/appliedepi/slides/master/images/logo.png", 
  title_slide_background_position = "95% 95%", 
  title_slide_background_size = "25%", 
  ## add logo to all following slides
  background_image = "https://raw.githubusercontent.com/appliedepi/slides/master/images/logo.png", 
  background_size = "10%",
  background_position = "100% 0%"
)
```

```{css, echo=F}
    .remark-slide table{
      border: none
    }
    .remark-slide-table {
      
    }
    tr:first-child {
      border-top: none;
  }
    tr:last-child {
    border-bottom: none;
  }
```

# Introducción a R para la epidemiología aplicada

### Unir marcos de datos

## [contact@appliedepi.org](mailto:contact@appliedepi.org)

# Hoy: objetivos y calendario

**En este módulo pretendemos ayudarte a**

- Aprende a unir dos o más marcos de datos
- Conoce las diferentes uniones y el uso de las columnas clave/identificador
- Practica el pivotaje de datos de formato ancho a largo para crear "líneas de tiempo" de pacientes
- Convertir variables en clase "factor" con la función {forcats} paquete

```{r, echo=FALSE, warning=F, message=F}
outline <- dplyr::tribble(
  ~Time, ~Topic,
  "20 minutes", "Demo: Joins",
  "1h 15 minutes", "Exercise: Joining data", 
  "15 minutes", "Demo: Pivoting data", 
  "1 hour",  "Exercise: Pivoting data & Factors", 
  "10 minutes", "Plenary debrief" 

)

outline %>% 
  flextable::qflextable() %>% 
  flextable::add_footer_lines("Take breaks as you wish during the exercise")
```

---

class: inverse, center, middle

# Unir marcos de datos

*Unir, fusionar, unir, combinar, ensamblar, enlazar, emparejar, unir* marcos de datos

.nota[Gracias a Garrick Aden-Buie por proporcionar los gifs utilizados en estas diapositivas]

???

Explícalo:

- las personas procedentes de distintos entornos pueden tener palabras diferentes para este tipo de operación: unir, juntar, fusionar, combinar, ensamblar...
- En este módulo, utilizaremos la palabra "unir" para ceñirnos a la `join_` familia de funciones de tidyverse, así como funciones bien conocidas de SQL. El equivalente en R es `merge`.

---

# Situación: los datos están dispersos entre marcos de datos

???

Pon ejemplos de situaciones con las que podrían encontrarse para poner de relieve lo común que es:

- conectar los datos de laboratorio con los resultados clínicos de los pacientes
- conectar los datos de los pacientes con los datos del SIG,
- conectar los datos de movilidad de Google con las tendencias de las enfermedades infecciosas
- otro ejemplo relevante para su trabajo insinuado por la encuesta de los participantes

---

# Tipos de uniones

#### Tipos de uniones

- **Uniones mutantes** Añadir una nueva variable a un marco de datos
  - **Unión izquierda** / **Unión der** Añadir datos a un marco de datos
  - **Unión completa**: combina dos marcos de datos completos
  - **Unión interna**: toma la intersección de dos marcos de datos
- **Filtrar uniones** filtrar un marco de datos a partir de otro
  - **Antiunión** / **semiunión**

#### Sintaxis general

- Utilizamos la `join` funciones de {dplyr} paquete
- Sintaxis homogénea:

```{r, include=TRUE, echo=TRUE, eval=FALSE}
xxx_join(dataframe_1, dataframe_2, 
         by = "key_id")
```

???
Insiste en que existen globalmente dos tipos de uniones, las uniones mutantes, que añadirán nuevas columnas, y potencialmente afectarán al número de líneas, y las uniones de filtrado, que no añadirán ninguna columna nueva, sólo cambiarán las filas de un conjunto de datos.

Explica que la función siempre tiene esta forma, dos marcos de datos, el primero se apoda *izquierda* y el segundo se llama *derecho* derecho. La dirección *por* proporciona columnas utilizadas para identificar coincidencias entre observaciones

---

# Ejemplo: añadir resultados de pacientes

```{r, include=FALSE, echo=F}
# Make smaller linelists for exemple purpose
# patients <- linelist_surv %>% 
#      select(case_id, age, age_unit, sex) %>% 
#      arrange(case_id) %>% 
#      head(5)

patients <- tribble(
     ~case_id, ~age, ~age_unit, ~sex,
     "5fe599", 2, "years", "m",
     "8689b7", 3, "years", "f",
     "11f8ea", 56, "years", "m",
     "b8812a", 18, "years", "f",
     "893f25", 3, "years", "m")


hosp <- tribble(
     ~id_patient, ~outcome,
      "5fe599", "Died",
      "8689b7", "Recovered",
      "11f8ea", "Recovered",
      "ebd24z", "Died")


# hosp <- linelist_surv %>% 
#      select(id_patient = case_id, hospital) %>% 
#      arrange(id_patient) %>% 
#      head(3)
```

Hagamos una demostración con estos pequeños conjuntos de datos: queremos *unir* ambos marcos de datos:

.pull-left[

`patients` *(Información sobre pacientes)*

```{r, include=TRUE, echo=FALSE}
patients %>% 
     # head(5) %>% 
     qflextable() %>% 
     bg(part = "header", i = 1, j = 1, bg = "yellow")
```

]

.pull-right[

`hosp` *(Información sobre hospitalizaciones)*

```{r, include=TRUE, echo=FALSE}
hosp %>% 
     # head(3) %>% 
     qflextable() %>% 
     bg(part = "header", i = 1, j = 1, bg = "yellow")
```

]

<br>

El **CLAVE** que vinculan los dos marcos de datos son **id\_caso** y **id\_paciente**

???
A efectos de las diapositivas, creamos dos *mini* marcos de datos para ver lo que ocurre, uno con las características del paciente (edad y sexo) y otro con el hospital en el que ha estado ingresado.
**Observa que ambos conjuntos de datos tienen en común el ID del paciente, pero un nombre ligeramente distinto (una situación muy común)**. A esta columna la llamamos CLAVE, o columna identificadora. Permite *coincidir con* observaciones en ambos marcos de datos.

---

# Unión izquierda

.pull-left[

- Las uniones a la izquierda suelen utilizarse para **añadir columnas** a un marco de datos.

- Todas las filas del marco de datos inicial (izquierdo) se mantienen

- Se unen las filas del segundo marco de datos (derecho) que coincidan

- Se añaden las columnas del segundo marco de datos (con `NA` rellenando los huecos)

]

.pull-right[

```{r, eval=TRUE, echo=FALSE, out.width="100%"}
knitr::include_graphics(xfun::relative_path(here::here("images", "joins_pivots", "left-join.gif")))
```

]

???
A veces llamado Izquierda *exterior* join

---

# Unión izquierda

.pull-left[

```{r, include=TRUE, echo=FALSE}
patients %>% 
     # head(5) %>% 
     qflextable() %>% 
     bg(part = "header", i = 1, j = 1, bg = "yellow")
```

]

.pull-right[

```{r, include=TRUE, echo=FALSE}
hosp %>% 
     # head(3) %>% 
     qflextable() %>% 
     bg(part = "header", i = 1, j = 1, bg = "yellow")

```

]

.pull-left[

```{r, echo=TRUE, eval=FALSE, include=TRUE}
left_join(patients, hosp,      
  by = c(
    "case_id" = "id_patient")) #<<
```

]

.pull-right[

```{r, include=TRUE, echo=FALSE, eval=TRUE, out.width="80%"}
left_join(patients, 
          hosp, 
     by = c("case_id" = "id_patient")) %>% 
     qflextable() %>% 
     bg(part = "header", i = 1, j = 1, bg = "yellow")



```

]

---

# Unión izquierda

.pull-left[

```{r, include=TRUE, echo=FALSE}
patients %>% 
     # head(5) %>% 
     qflextable() %>% 
     bg(part = "header", i = 1, j = 1, bg = "yellow")
```

]

.pull-right[

```{r, include=TRUE, echo=FALSE}
hosp %>% 
     # head(3) %>% 
     qflextable() %>% 
     bg(part = "header", i = 1, j = 1, bg = "yellow") %>% 
     bg(part = "body",   i = 4, j = 1:2, bg = "red") %>% 
     bg(part = "body",   i = 1:3, j = 2, bg = "lightgreen")


```

]

.pull-left[

```{r, echo=TRUE, eval=FALSE, include=TRUE}
left_join(patients, hosp,      
  by = c(
    "case_id" = "id_patient")) #<<
```

]

.pull-right[

```{r, include=TRUE, echo=FALSE, eval=TRUE, out.width="80%"}
left_join(patients, 
          hosp, 
     by = c("case_id" = "id_patient")) %>% 
     qflextable() %>% 
     bg(part = "header", i = 1, j = 1, bg = "yellow") %>% 
     bg(part = "header", i = 1, j = 5, bg = "lightgreen") %>% 
     bg(part = "body",   i = 1:3, j = 5, bg = "lightgreen")


```

]

---

# Junta derecha

.pull-left[

- No se utiliza muy a menudo

- Mantiene las filas coincidentes del marco de datos de referencia

- Añade *las no coincidentes* filas del segundo marco de datos

- Añade columnas del segundo marco de datos

]

.pull-right[

```{r, eval=TRUE, echo=FALSE, out.width="100%"}
knitr::include_graphics(xfun::relative_path(here::here("images", "joins_pivots", "right-join.gif")))
```

]

---

# Junta derecha

.pull-left[

```{r, include=TRUE, echo=FALSE}
patients %>% 
     # head(5) %>% 
     qflextable() %>% 
     bg(part = "body",   i = 4:5, j = 1:4, bg = "red")

```

]

.pull-right[

```{r, include=TRUE, echo=FALSE}
hosp %>% 
     # head(3) %>% 
     qflextable()
```

]

.pull-left[

```{r, echo=TRUE, eval=FALSE, include=TRUE}
right_join(patients, hosp,      
  by = c(
    "case_id" = "id_patient")) 
```

]

.pull-right[

```{r, include=TRUE, echo=FALSE, eval=TRUE, out.width="80%"}
right_join(patients, 
          hosp, 
     by = c("case_id" = "id_patient")) %>% 
     qflextable() %>% 
     bg(part = "header", i = 1, j = 5, bg = "lightgreen") %>% 
     bg(part = "body",   i = 1:4, j = 5, bg = "lightgreen") %>% 
     bg(part = "body",   i = 4, j = 1, bg = "lightgreen")


```

]

???
No se utiliza muy a menudo.

---

# Uniones completas

.pull-left[

- La más inclusiva de las uniones

- Conserva **todas las filas de ambos marcos de datos**

- Rellena los espacios con `NA` según sea necesario

]

.pull-right[

```{r, eval=TRUE, echo=FALSE, out.width="100%"}
knitr::include_graphics(xfun::relative_path(here::here("images", "joins_pivots", "full-join.gif")))
```

]

.footnote[A veces llamada *Unión externa completa* o *Unión ext*]

---

# A veces llamada *Unión externa completa* o *Unión ext*

.pull-left[

```{r, include=TRUE, echo=FALSE}
patients %>% 
     # head(5) %>% 
     qflextable()
```

]

.pull-right[

```{r, include=TRUE, echo=FALSE}
hosp %>% 
     # head(3) %>% 
     qflextable()
```

]

.pull-left[

```{r, echo=TRUE, eval=FALSE, include=TRUE}
full_join(patients, hosp,       
  by = c(
    "case_id" = "id_patient")) 
```

]

.pull-right[

```{r, include=TRUE, echo=FALSE, eval=TRUE, out.width="80%"}
full_join(patients, 
          hosp, 
     by = c("case_id" = "id_patient")) %>% 
     qflextable() %>% 
     bg(part = "header", i = 1, j = 5, bg = "lightgreen") %>% 
     bg(part = "body",   i = c(1:3, 6), j = 5, bg = "lightgreen") %>% 
     bg(part = "body",   i = 6, j = 1, bg = "lightgreen")


```

]

???
Ahora es un buen momento para insistir en lo coherentes que son los argumentos de la familia de funciones join: siempre se escriben de la misma manera

---

# Unión interna

.pull-left[

- Lo más **restrictivo** de uniones

- Toma el **intersección** entre dos marcos de datos: mantiene sólo las filas que coinciden

- **Descarta** filas sin coincidencias

]

.pull-right[

```{r, eval=TRUE, echo=FALSE, out.width="100%"}
knitr::include_graphics(xfun::relative_path(here::here("images", "joins_pivots", "inner-join.gif")))
```

]

.footnote[También llamada *unión natural*]

???
Bueno, todas las viñetas dicen más o menos lo mismo, pero creo que es bueno asegurarse de que todo el mundo entiende lo que significa tomar el *intersección*.

---

# Unión interna

.pull-left[

```{r, include=TRUE, echo=FALSE}
patients %>% 
     # head(5) %>% 
     qflextable() %>% 
     bg(part = "body",   i = 4:5, j = 1:4, bg = "red")

```

]

.pull-right[

```{r, include=TRUE, echo=FALSE}
hosp %>% 
     # head(3) %>% 
     qflextable() %>% 
     bg(part = "body",   i = 4, j = 1:2, bg = "red")

```

]

.pull-left[

```{r, echo=TRUE, eval=FALSE, include=TRUE}
inner_join(patients, hosp,       
  by = c(
    "case_id" = "id_patient")) 
```

]

.pull-right[

```{r, include=TRUE, echo=FALSE, eval=TRUE, out.width="80%"}
inner_join(patients, 
          hosp, 
     by = c("case_id" = "id_patient")) %>% 
     qflextable() %>% 
     bg(part = "header", i = 1, j = 5, bg = "lightgreen") %>% 
     bg(part = "body",   i = c(1:3), j = 5, bg = "lightgreen") 

```

]

---

# Consejos de sintaxis

- Las uniones pueden utilizarse en **canalizaciones** (el marco de datos canalizado es el *izquierda* izquierda):

```{r, echo=TRUE, eval=FALSE, include=TRUE}
patients %>%               
     left_join(hosp, by = c("case_id" = "id_patient")) %>%  #<<
     filter(age > 25)
```

--

- Sintaxis simple si **la columna identificadora tiene el mismo** en ambos marcos de datos:

```{r, echo=TRUE, eval=FALSE, include=TRUE}
left_join(patients, hosp,       
           by = "case_id")   #<<
```

--

- Pasa **varias columnas** para utilizarlas como identificadores:

```{r, echo=TRUE, eval=FALSE, include=TRUE}
left_join(dataframe1, dataframe2,       
           by = c("name" = "first_name",  
                  "age",       #<<
                  "sex"))   #<<
```

---

# Filtrar uniones

- Las uniones filtrantes se utilizan para **filtrar filas** de la *línea de base* basándose en las coincidencias del segundo marco de datos.
- Filtrado de uniones *no añadir columnas ni filas*

.pull-left[

#### Anti join

Mantiene las filas base  
**sin coincidencias en otro marco de datos**

```{r, eval=TRUE, echo=FALSE, out.width="50%"}
knitr::include_graphics(xfun::relative_path(here::here("images", "joins_pivots", "anti-join.gif")))
```

]

.pull-right[

#### Semiunión

Mantiene las filas base  
**con una coincidencia en otro marco de datos**

```{r, eval=TRUE, echo=FALSE, out.width="50%"}
knitr::include_graphics(xfun::relative_path(here::here("images", "joins_pivots", "semi-join.gif")))
```

]

**Las uniones filtrantes nunca duplican filas, sólo pueden eliminarlas**

???
Las uniones anti son muy útiles para ver qué filas de un conjunto de datos *no* coinciden con

---

# Desafíos de la vida real

---

# Superposición de nombres de columnas

```{r, eval=TRUE, echo=FALSE}
df1 <- tibble(ID = c("id_1", "id_2", "id_3", "id_4"), sexe = c("F", "M", "M", "F"))
df2 <- tibble(ID = c("id_1", "id_2", "id_5"), age = c(5, 5, 7), sexe = c("F", "F", "F"))
```

.pull-left[

```{r, eval=TRUE, echo=FALSE}
patients %>% 
     qflextable() %>% 
     bg(part = "body", i = 1:5, j = 2, bg = "orange") %>% 
     bg(part = "header", i = 1, j = 2, bg = "orange")

```

]

.pull-right[

```{r, eval=TRUE, echo=FALSE}
hosp %>%
     mutate(age = c(2, 3, 56, 40)) %>% 
     qflextable() %>% 
     bg(part = "body", i = c(1:4), j = 3, bg = "orange") %>% 
     bg(part = "header", i = 1, j = 3, bg = "orange") 

```

]

.pull-left[

```{r, eval=FALSE, echo=TRUE}
left_join(patients, hosp,
  by = c(
   "case_id" = "id_patient"))
```

]

.pull-right[

```{r, eval=TRUE, echo=FALSE}
left_join(patients,
          hosp %>% mutate(age = c(2, 3, 56, 40)),
  by = c("case_id" = "id_patient")) %>% 
  qflextable() %>% 
  bg(part = "header", i = 1, j = 2, bg = "orange") %>% 
  bg(part = "header", i = 1, j = 6, bg = "orange") 
```

]

???
Si las columnas son comunes, R cambiará su nombre para desambiguarlas.

- Si estás seguro de que ambas columnas contienen la misma información, elimínalas de uno de los marcos de datos antes de la unión
- Si no estás seguro, puedes compararlas fácilmente después de la unión.
  Menciona oralmente que existe un argumento "sufijo" y que puedes darle un vector para renombrarlo en lugar de .x y .y

---

# Superposición de nombres de columnas

.pull-left[

```{r, eval=TRUE, echo=FALSE}
patients %>% 
     qflextable() %>% 
     bg(part = "body", i = 1:5, j = 2, bg = "orange") %>% 
     bg(part = "header", i = 1, j = 2, bg = "orange")

```

]

.pull-right[

```{r, eval=TRUE, echo=FALSE}
hosp %>%
     mutate(age = c(2, 3, 56, 40)) %>% 
     qflextable() %>% 
     bg(part = "body", i = c(1:4), j = 3, bg = "orange") %>% 
     bg(part = "header", i = 1, j = 3, bg = "orange") 

```

]

.pull-left[

```{r, eval=FALSE, echo=TRUE}
left_join(patients, hosp,
  by = c(
   "case_id" = "id_patient",
   "age"))    #<<
```

]

.pull-right[

```{r, eval=TRUE, echo=FALSE}
left_join(patients,
          hosp %>% mutate(age = c(2, 3, 56, 40)),
  by = c("case_id" = "id_patient", "age")) %>% 
  qflextable() %>% 
  bg(part = "header", i = 1, j = 2, bg = "orange")
```

]

???
Si las columnas son comunes, R cambiará su nombre para desambiguarlas.

- Si estás seguro de que ambas columnas contienen la misma información, elimínalas de uno de los marcos de datos antes de la unión
- Si no estás seguro, puedes compararlas fácilmente después de la unión.
  Menciona oralmente que existe un argumento "sufijo" y que puedes darle un vector para renombrarlo en lugar de .x y .y

---

### De uno a muchos

.pull-left[

```{r, eval=TRUE, echo=FALSE}
patients %>% 
     qflextable() %>% 
     bg(part = "body", i = 1, j = 1:4, bg = "orange")
```

]
.pull-right[

```{r, eval=TRUE, echo=FALSE}

hosp_dup <- tribble(
     ~id_patient, ~outcome,
      "5fe599", "Died",
      "5fe599", "Alive",
      "8689b7", "Recovered",
      "11f8ea", "Recovered",
      "ebd24z", "Died")

hosp_dup %>%
    qflextable() %>% 
     bg(part = "body", i = 1:2, j = 1:2, bg = "orange")
```

]
.pull-left[ ]

```{r, eval=FALSE, echo=TRUE}
left_join(patients, hosp,
  by = c(
   "case_id" = "id_patient"))
```

]
.pull-derecha\[ ]

```{r, eval=TRUE, echo=FALSE}
left_join(patients,
          hosp_dup,
  by = c("case_id" = "id_patient")) %>% 
  qflextable() %>% 
  bg(part = "body", i = 1:2, j = 1:5, bg = "orange")
```

]

---

### Muchos a uno

.pull-left[

```{r, eval=TRUE, echo=FALSE}

patients_dup <- tribble(
     ~case_id, ~age, ~age_unit, ~sex,
     "5fe599", 2, "years", "m",
     "5fe599", 2, "years", "m",
     "8689b7", 3, "years", "f",
     "11f8ea", 56, "years", "m",
     "b8812a", 18, "years", "f",
     "893f25", 3, "years", "m")


patients_dup %>% 
     qflextable() %>% 
     bg(part = "body", i = 1:2, j = 1:4, bg = "orange")
```

]
.pull-derecha\[ ]

```{r, eval=TRUE, echo=FALSE}

hosp %>%
    qflextable() %>% 
     bg(part = "body", i = 1, j = 1:2, bg = "orange")
```

]
.pull-left[ ]

```{r, eval=FALSE, echo=TRUE}
left_join(patients, hosp,
  by = c(
   "case_id" = "id_patient"))
```

]
.pull-derecha\[ ]

```{r, eval=TRUE, echo=FALSE}
left_join(patients_dup,
          hosp,
  by = c("case_id" = "id_patient")) %>% 
  qflextable() %>% 
  bg(part = "body", i = 1:2, j = 1:5, bg = "orange")
```

]

---

# Buenas prácticas

Utiliza `semi_join()` y `anti_join()` para **entender por qué se eliminan filas**

"¿Qué `hosp` filas no se unirán por la izquierda a `patients`?" Examina por qué con `anti_join()`

```{r, eval=FALSE, echo=TRUE}
anti_join(hosp, patients, by = c("id_patient" = "case_id"))
```

```{r, eval=TRUE, echo=FALSE}
anti_join(hosp, patients, by = c("id_patient" = "case_id")) %>% 
     qflextable()
```

---

# Buenas prácticas

**Comprueba las dimensiones** ¡de los marcos de datos antes y después de la fusión!

```{r, eval=TRUE, echo=TRUE}
nrow(patients)
```

```{r, eval=TRUE, echo=TRUE}
nrow(hosp)
```

```{r, eval=TRUE, echo=TRUE}
left_join(patients, hosp, by = c("case_id" = "id_patient")) %>%
  nrow()
```

???
Otra buena comprobación es utilizar la función `count()` para contar el número de filas de cada uno de tus identificadores.

---

class: inverse, center, middle

# Ejercicio

Ir al sitio web del curso  
Abre el ejercicio del Módulo 7 parte 1, e inicia sesión  
Sigue las instrucciones para abrir tu proyecto R "ebola" y continúa codificando en tu script RMD
Avisa a un instructor si no estás seguro de lo que tienes que hacer

```{r, eval=TRUE, echo=FALSE, out.width="50%"}
# Using here() alone won't work because Rmd folder becomes the rendering root.
# adding xfun::relative_path() creates a dynamic file path between the Rmd location and the here() path.
# It dynamically creates the ../../etc filepath.

knitr::include_graphics(xfun::relative_path(here::here("images", "breakout", "window.png")))
```



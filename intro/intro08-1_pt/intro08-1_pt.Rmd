---
title: Introdução ao R para<br>Epidemiologia aplicada
subtitle: Joining data
author: '2022'
date: '[contact@appliedepi.org](mailto:contact@appliedepi.org)'
output:
  xaringan::moon_reader:
    seal: false
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
    css: xaringan-themer.css
params:
  lang: en
---

class: center, middle, inverse, title-slide

```{r, eval=F, echo=F, include=F}
# Must do in order to render.

pacman::p_load(xaringan)
devtools::install_github("gadenbuie/xaringanExtra")
remotes::install_github("mitchelloharawild/icons")
icons::download_fontawesome()

# Render with xaringan::infinite_moon_reader()
# Slides will appear in viewer, and will update as you edit/save
```

```{r setup, include=FALSE, echo=F}
knitr::opts_chunk$set(echo = FALSE, 
                      warning = FALSE, 
                      message = FALSE, 
                      fig.retina = 3  ## retina more effective than w/h (according to twitter)
                      # fig.width = 16, 
                      # fig.height = 10
                      )
## I dont know why this is included in the example xaringan slide 
## but is something to do with background images
options(htmltools.dir.version = FALSE)

## install and load necessary packages 
pacman::p_load(
  rio,        # importing data  
  here,       # relative file pathways  
  janitor,    # data cleaning and tables
  lubridate,  # working with dates
  tidyverse,  # data management and visualization
  gtsummary,  # summary tables
  countdown,  # countdown timer
  flextable,  # tables
  kableExtra, # for output tables
  xaringanthemer  # for styling presentation 
)


# data prep --------------------------------------------------------------------
# linelist_raw <- rio::import(here::here("data", "linelist_raw.xlsx"))
linelist_surv <- rio::import(here::here("data", "surveillance_linelist_clean_20141201.rds"))

# gen <- googlesheets4::read_sheet(
#   "https://docs.google.com/spreadsheets/d/1-Xqv5xvakmhKSxipVP6a9GF3H54RN-rbilhdNhPHx6M/edit#gid=998182281",
#   range = "generic") %>%
#   clean_names()
# 
# mod7_1 <- googlesheets4::read_sheet(
#   "https://docs.google.com/spreadsheets/d/1-Xqv5xvakmhKSxipVP6a9GF3H54RN-rbilhdNhPHx6M/edit#gid=998182281",
#   range = "mod7_1", col_types = "c") %>%
#   clean_names()
```

```{r xaringan-themer, include=FALSE}

## define presentation colours (theme) using {xaringanthemer} package 
## https://pkg.garrickadenbuie.com/xaringanthemer/articles/xaringanthemer.html

## epirhandbook logo colours: 
  ## blue: "#00538c"
  ## green: "#007732"
  ## lighter green: "#48a878"

## see ?style_mono_accent for all the things can customise
style_mono_accent(
  base_color = "#00538c", 
  link_color = "#48a878", 
  ## add logo to the title page (bit bigger)
  title_slide_background_image = "https://raw.githubusercontent.com/appliedepi/slides/master/images/logo.png", 
  title_slide_background_position = "95% 95%", 
  title_slide_background_size = "25%", 
  ## add logo to all following slides
  background_image = "https://raw.githubusercontent.com/appliedepi/slides/master/images/logo.png", 
  background_size = "10%",
  background_position = "100% 0%"
)
```

```{css, echo=F}
    .remark-slide table{
      border: none
    }
    .remark-slide-table {
      
    }
    tr:first-child {
      border-top: none;
  }
    tr:last-child {
    border-bottom: none;
  }
```

# Introdução ao R para Epidemiologia Aplicada

### Junção de quadros de dados

[contact@appliedepi.org](mailto:contact@appliedepi.org)
---

# Hoje: objetivos e cronograma

**Neste módulo, pretendemos ajudar você a:**

- Saiba como unir dois ou mais quadros de dados
- Saiba mais sobre as diferentes uniões e o uso de chaves de identificação/colunas de identificação
- Pratique a dinamização de dados do formato largo para o longo para criar "linhas do tempo" de pacientes
- Converta variáveis em "fator" de classe com a função {forcats} pacote

```{r, echo=FALSE, warning=F, message=F}
outline <- dplyr::tribble(
  ~Time, ~Topic,
  "20 minutes", "Demo: Joins",
  "1h 15 minutes", "Exercise: Joining data", 
  "15 minutes", "Demo: Pivoting data", 
  "1 hour",  "Exercise: Pivoting data & Factors", 
  "10 minutes", "Plenary debrief" 

)

outline %>% 
  flextable::qflextable() %>% 
  flextable::add_footer_lines("Take breaks as you wish during the exercise")
```

---

class: inverse, center, middle

# Unindo quadros de dados

*Juntar, mesclar, unir, combinar, montar, vincular, combinar, unir* quadros de dados

.footnote [Obrigado a Garrick Aden-Buie por fornecer os gifs usados nestes slides]

???

Explique isso:

- pessoas de diferentes origens podem ter palavras diferentes para esse tipo de operação: juntar, unir, fundir, combinar, montar...
- Neste módulo, usaremos a palavra "juntar" para nos atermos ao conceito de `join_` da família de funções do tidyverse, bem como funções bem conhecidas do SQL. O equivalente básico em R é `merge`.

---

# Situação: os dados estão dispersos entre os quadros de dados

???

Forneça exemplos de situações que eles podem encontrar para destacar o quanto isso é comum:

- conectar dados laboratoriais aos resultados clínicos do paciente
- conectar dados de pacientes com dados GIS,
- conectar dados de mobilidade do Google a tendências de doenças infecciosas
- outro exemplo relevante para seu trabalho, sugerido pela pesquisa dos participantes

---

# Tipos de junções

#### Tipos de uniões

- **Uniões mutantes** Adicionar nova variável a um dataframe: adicionar nova variável a um dataframe
  - **União à esquerda** / **União à direita** Adicionar dados a um quadro de dados
  - **Junção completa**: combina dois quadros de dados completos
  - **União interna**: obtém a interseção de dois quadros de dados
- **Filtragem de uniões** Filtrar um dataframe com base em outro
  - **Anti-junção** / **Semi-adesão**

#### Sintaxe geral

- Usamos o `join` funções de {dplyr} pacote
- Sintaxe homogênea:

```{r, include=TRUE, echo=TRUE, eval=FALSE}
xxx_join(dataframe_1, dataframe_2, 
         by = "key_id")
```

???
Insista em que existem globalmente dois tipos de junções: as junções mutantes, que adicionarão novas colunas e possivelmente afetarão o número de linhas, e as junções filtrantes, que não adicionarão novas colunas, apenas alterarão as linhas em um conjunto de dados.

Explique que a função está sempre nesse formato, dois quadros de dados, o primeiro deles é chamado de *esquerda* e o segundo é chamado de dataframe *direito* direito. O *por* fornece colunas usadas para identificar correspondências entre observações

---

# Exemplo: adicionar resultados de pacientes

```{r, include=FALSE, echo=F}
# Make smaller linelists for exemple purpose
# patients <- linelist_surv %>% 
#      select(case_id, age, age_unit, sex) %>% 
#      arrange(case_id) %>% 
#      head(5)

patients <- tribble(
     ~case_id, ~age, ~age_unit, ~sex,
     "5fe599", 2, "years", "m",
     "8689b7", 3, "years", "f",
     "11f8ea", 56, "years", "m",
     "b8812a", 18, "years", "f",
     "893f25", 3, "years", "m")


hosp <- tribble(
     ~id_patient, ~outcome,
      "5fe599", "Died",
      "8689b7", "Recovered",
      "11f8ea", "Recovered",
      "ebd24z", "Died")


# hosp <- linelist_surv %>% 
#      select(id_patient = case_id, hospital) %>% 
#      arrange(id_patient) %>% 
#      head(3)
```

Vamos fazer uma demonstração com esses pequenos conjuntos de dados: queremos que você *juntar* ambos os quadros de dados:

.pull-left[

`patients` *(Informações sobre os pacientes)*

```{r, include=TRUE, echo=FALSE}
patients %>% 
     # head(5) %>% 
     qflextable() %>% 
     bg(part = "header", i = 1, j = 1, bg = "yellow")
```

]

.pull-right[

`hosp` *(Informações sobre hospitalizações)*

```{r, include=TRUE, echo=FALSE}
hosp %>% 
     # head(3) %>% 
     qflextable() %>% 
     bg(part = "header", i = 1, j = 1, bg = "yellow")
```

]

<br>

O **CHAVE** que vinculam os dois quadros de dados são **case\_id** e **id\_paciente**

???
Para os fins dos slides, criamos dois *mini* quadros de dados para ver o que está acontecendo, um com as características do paciente (idade e sexo) e o outro com o hospital em que o paciente foi internado.
**Observe que ambos os conjuntos de dados têm o ID do paciente em comum, mas um nome ligeiramente diferente (uma situação muito comum)**. Chamamos essa coluna de KEY, ou coluna de identificador. Ela permite que você *corresponder* observações em ambos os quadros de dados.

---

# União à esquerda

.pull-left[

- As junções à esquerda são frequentemente usadas para **adicionar colunas** a um quadro de dados.

- Todas as linhas do quadro de dados da linha de base (esquerda) são mantidas

- As linhas do segundo quadro de dados (direito) que coincidem são unidas

- As colunas do segundo quadro de dados são adicionadas (com `NA` preenchendo todas as lacunas)

]

.pull-right[

```{r, eval=TRUE, echo=FALSE, out.width="100%"}
knitr::include_graphics(xfun::relative_path(here::here("images", "joins_pivots", "left-join.gif")))
```

]

???
Às vezes chamado de esquerda *externo* esquerda

---

# União esquerda

.pull-left[

```{r, include=TRUE, echo=FALSE}
patients %>% 
     # head(5) %>% 
     qflextable() %>% 
     bg(part = "header", i = 1, j = 1, bg = "yellow")
```

]

.pull-right[

```{r, include=TRUE, echo=FALSE}
hosp %>% 
     # head(3) %>% 
     qflextable() %>% 
     bg(part = "header", i = 1, j = 1, bg = "yellow")

```

]

.pull-left[

```{r, echo=TRUE, eval=FALSE, include=TRUE}
left_join(patients, hosp,      
  by = c(
    "case_id" = "id_patient")) #<<
```

]

.pull-right[

```{r, include=TRUE, echo=FALSE, eval=TRUE, out.width="80%"}
left_join(patients, 
          hosp, 
     by = c("case_id" = "id_patient")) %>% 
     qflextable() %>% 
     bg(part = "header", i = 1, j = 1, bg = "yellow")



```

]

---

# União à esquerda

.pull-left[

```{r, include=TRUE, echo=FALSE}
patients %>% 
     # head(5) %>% 
     qflextable() %>% 
     bg(part = "header", i = 1, j = 1, bg = "yellow")
```

]

.pull-right[

```{r, include=TRUE, echo=FALSE}
hosp %>% 
     # head(3) %>% 
     qflextable() %>% 
     bg(part = "header", i = 1, j = 1, bg = "yellow") %>% 
     bg(part = "body",   i = 4, j = 1:2, bg = "red") %>% 
     bg(part = "body",   i = 1:3, j = 2, bg = "lightgreen")


```

]

.pull-left[

```{r, echo=TRUE, eval=FALSE, include=TRUE}
left_join(patients, hosp,      
  by = c(
    "case_id" = "id_patient")) #<<
```

]

.pull-right[

```{r, include=TRUE, echo=FALSE, eval=TRUE, out.width="80%"}
left_join(patients, 
          hosp, 
     by = c("case_id" = "id_patient")) %>% 
     qflextable() %>% 
     bg(part = "header", i = 1, j = 1, bg = "yellow") %>% 
     bg(part = "header", i = 1, j = 5, bg = "lightgreen") %>% 
     bg(part = "body",   i = 1:3, j = 5, bg = "lightgreen")


```

]

---

# Junção correta

.pull-left[

- Não é usado com muita frequência

- Mantém as linhas correspondentes do quadro de dados de linha de base

- Adiciona *sem correspondência* linhas do segundo quadro de dados

- Adiciona colunas do segundo quadro de dados

]

.pull-right[

```{r, eval=TRUE, echo=FALSE, out.width="100%"}
knitr::include_graphics(xfun::relative_path(here::here("images", "joins_pivots", "right-join.gif")))
```

]

---

# Junção correta

.pull-left[

```{r, include=TRUE, echo=FALSE}
patients %>% 
     # head(5) %>% 
     qflextable() %>% 
     bg(part = "body",   i = 4:5, j = 1:4, bg = "red")

```

]

.pull-right[

```{r, include=TRUE, echo=FALSE}
hosp %>% 
     # head(3) %>% 
     qflextable()
```

]

.pull-left[

```{r, echo=TRUE, eval=FALSE, include=TRUE}
right_join(patients, hosp,      
  by = c(
    "case_id" = "id_patient")) 
```

]

.pull-right[

```{r, include=TRUE, echo=FALSE, eval=TRUE, out.width="80%"}
right_join(patients, 
          hosp, 
     by = c("case_id" = "id_patient")) %>% 
     qflextable() %>% 
     bg(part = "header", i = 1, j = 5, bg = "lightgreen") %>% 
     bg(part = "body",   i = 1:4, j = 5, bg = "lightgreen") %>% 
     bg(part = "body",   i = 4, j = 1, bg = "lightgreen")


```

]

???
Não é usado com muita frequência.

---

# Juntas completas

.pull-left[

- A mais inclusiva das uniões

- Mantém **todas as linhas de ambos os quadros de dados**

- Preenche os espaços com `NA` conforme necessário

]

.pull-right[

```{r, eval=TRUE, echo=FALSE, out.width="100%"}
knitr::include_graphics(xfun::relative_path(here::here("images", "joins_pivots", "full-join.gif")))
```

]

.footnote[Às vezes chamada de *junção externa completa* ou *Junção externa*]

---

# Às vezes chamada de *junção externa completa* ou *Junção externa*

.pull-left[

```{r, include=TRUE, echo=FALSE}
patients %>% 
     # head(5) %>% 
     qflextable()
```

]

.pull-right[

```{r, include=TRUE, echo=FALSE}
hosp %>% 
     # head(3) %>% 
     qflextable()
```

]

.pull-left[

```{r, echo=TRUE, eval=FALSE, include=TRUE}
full_join(patients, hosp,       
  by = c(
    "case_id" = "id_patient")) 
```

]

.pull-right[

```{r, include=TRUE, echo=FALSE, eval=TRUE, out.width="80%"}
full_join(patients, 
          hosp, 
     by = c("case_id" = "id_patient")) %>% 
     qflextable() %>% 
     bg(part = "header", i = 1, j = 5, bg = "lightgreen") %>% 
     bg(part = "body",   i = c(1:3, 6), j = 5, bg = "lightgreen") %>% 
     bg(part = "body",   i = 6, j = 1, bg = "lightgreen")


```

]

???
Agora é um bom momento para insistir na consistência dos argumentos da família de funções de união: você sempre os escreve da mesma forma

---

# Junção interna

.pull-left[

- O mais **restritivo** das uniões

- Pega o **interseção** entre dois quadros de dados: mantém apenas as linhas que correspondem a você

- **Descartar** linhas sem correspondências

]

.pull-right[

```{r, eval=TRUE, echo=FALSE, out.width="100%"}
knitr::include_graphics(xfun::relative_path(here::here("images", "joins_pivots", "inner-join.gif")))
```

]

.footnote[Também chamada de *junção natural*]

???
Bem, todos os itens dizem mais ou menos a mesma coisa, mas acho que é bom ter certeza de que todos entendem o que significa tomar o *interseção*.

---

# União interna

.pull-left[

```{r, include=TRUE, echo=FALSE}
patients %>% 
     # head(5) %>% 
     qflextable() %>% 
     bg(part = "body",   i = 4:5, j = 1:4, bg = "red")

```

]

.pull-right[

```{r, include=TRUE, echo=FALSE}
hosp %>% 
     # head(3) %>% 
     qflextable() %>% 
     bg(part = "body",   i = 4, j = 1:2, bg = "red")

```

]

.pull-left[

```{r, echo=TRUE, eval=FALSE, include=TRUE}
inner_join(patients, hosp,       
  by = c(
    "case_id" = "id_patient")) 
```

]

.pull-right[

```{r, include=TRUE, echo=FALSE, eval=TRUE, out.width="80%"}
inner_join(patients, 
          hosp, 
     by = c("case_id" = "id_patient")) %>% 
     qflextable() %>% 
     bg(part = "header", i = 1, j = 5, bg = "lightgreen") %>% 
     bg(part = "body",   i = c(1:3), j = 5, bg = "lightgreen") 

```

]

---

# Dicas de sintaxe

- As junções podem ser usadas em **pipelines** (o dataframe canalizado é o *esquerdo* esquerdo):

```{r, echo=TRUE, eval=FALSE, include=TRUE}
patients %>%               
     left_join(hosp, by = c("case_id" = "id_patient")) %>%  #<<
     filter(age > 25)
```

--

- Sintaxe simples se **a coluna do identificador tiver o mesmo nome** em ambos os quadros de dados:

```{r, echo=TRUE, eval=FALSE, include=TRUE}
left_join(patients, hosp,       
           by = "case_id")   #<<
```

--

- Passe **várias colunas** para usar como identificadores:

```{r, echo=TRUE, eval=FALSE, include=TRUE}
left_join(dataframe1, dataframe2,       
           by = c("name" = "first_name",  
                  "age",       #<<
                  "sex"))   #<<
```

---

# Filtragem de uniões

- As uniões de filtragem são usadas para **filtrar linhas** do *linha de base* com base nas correspondências no segundo quadro de dados.
- Filtragem de junções *não adicionar nenhuma coluna ou linha*

.pull-left[

#### Anti-junção

Mantém as linhas de base  
**sem correspondências em outro dataframe**

```{r, eval=TRUE, echo=FALSE, out.width="50%"}
knitr::include_graphics(xfun::relative_path(here::here("images", "joins_pivots", "anti-join.gif")))
```

]

.pull-right[

#### Semi join

Mantém as linhas de base  
**com uma correspondência em outro quadro de dados**

```{r, eval=TRUE, echo=FALSE, out.width="50%"}
knitr::include_graphics(xfun::relative_path(here::here("images", "joins_pivots", "semi-join.gif")))
```

]

**As uniões de filtragem nunca duplicam linhas, apenas podem eliminá-las**

???
Anti-uniões são muito úteis para ver quais linhas em um conjunto de dados fazem *não* correspondem

---

# Desafios da vida real

---

# Sobreposição de nomes de colunas

```{r, eval=TRUE, echo=FALSE}
df1 <- tibble(ID = c("id_1", "id_2", "id_3", "id_4"), sexe = c("F", "M", "M", "F"))
df2 <- tibble(ID = c("id_1", "id_2", "id_5"), age = c(5, 5, 7), sexe = c("F", "F", "F"))
```

.pull-left[

```{r, eval=TRUE, echo=FALSE}
patients %>% 
     qflextable() %>% 
     bg(part = "body", i = 1:5, j = 2, bg = "orange") %>% 
     bg(part = "header", i = 1, j = 2, bg = "orange")

```

]

.pull-right[

```{r, eval=TRUE, echo=FALSE}
hosp %>%
     mutate(age = c(2, 3, 56, 40)) %>% 
     qflextable() %>% 
     bg(part = "body", i = c(1:4), j = 3, bg = "orange") %>% 
     bg(part = "header", i = 1, j = 3, bg = "orange") 

```

]

.pull-left[

```{r, eval=FALSE, echo=TRUE}
left_join(patients, hosp,
  by = c(
   "case_id" = "id_patient"))
```

]

.pull-right[

```{r, eval=TRUE, echo=FALSE}
left_join(patients,
          hosp %>% mutate(age = c(2, 3, 56, 40)),
  by = c("case_id" = "id_patient")) %>% 
  qflextable() %>% 
  bg(part = "header", i = 1, j = 2, bg = "orange") %>% 
  bg(part = "header", i = 1, j = 6, bg = "orange") 
```

]

???
Se as colunas estiverem em comum, o R mudará o nome delas para desambiguá-las.

- Se você tiver certeza de que as duas colunas contêm as mesmas informações, remova-as de um dos quadros de dados antes da união
- Se não tiver certeza, você poderá compará-las facilmente após a união.
  Mencione oralmente que há um argumento "sufixo" e que você pode dar a ele um vetor para renomear em vez de .x e .y

---

# Nomes de colunas sobrepostos

.pull-left[

```{r, eval=TRUE, echo=FALSE}
patients %>% 
     qflextable() %>% 
     bg(part = "body", i = 1:5, j = 2, bg = "orange") %>% 
     bg(part = "header", i = 1, j = 2, bg = "orange")

```

]

.pull-right[

```{r, eval=TRUE, echo=FALSE}
hosp %>%
     mutate(age = c(2, 3, 56, 40)) %>% 
     qflextable() %>% 
     bg(part = "body", i = c(1:4), j = 3, bg = "orange") %>% 
     bg(part = "header", i = 1, j = 3, bg = "orange") 

```

]

.pull-left[

```{r, eval=FALSE, echo=TRUE}
left_join(patients, hosp,
  by = c(
   "case_id" = "id_patient",
   "age"))    #<<
```

]

.pull-right[

```{r, eval=TRUE, echo=FALSE}
left_join(patients,
          hosp %>% mutate(age = c(2, 3, 56, 40)),
  by = c("case_id" = "id_patient", "age")) %>% 
  qflextable() %>% 
  bg(part = "header", i = 1, j = 2, bg = "orange")
```

]

???
Se as colunas estiverem em comum, o R mudará o nome delas para desambiguá-las.

- Se você tiver certeza de que as duas colunas contêm as mesmas informações, remova-as de um dos quadros de dados antes da união
- Se não tiver certeza, você poderá compará-las facilmente após a união.
  Mencione oralmente que há um argumento "sufixo" e que você pode dar a ele um vetor para renomear em vez de .x e .y

---

### Um para muitos

.pull-left[

```{r, eval=TRUE, echo=FALSE}
patients %>% 
     qflextable() %>% 
     bg(part = "body", i = 1, j = 1:4, bg = "orange")
```

]
.pull-right[

```{r, eval=TRUE, echo=FALSE}

hosp_dup <- tribble(
     ~id_patient, ~outcome,
      "5fe599", "Died",
      "5fe599", "Alive",
      "8689b7", "Recovered",
      "11f8ea", "Recovered",
      "ebd24z", "Died")

hosp_dup %>%
    qflextable() %>% 
     bg(part = "body", i = 1:2, j = 1:2, bg = "orange")
```

]
.pull-left[

```{r, eval=FALSE, echo=TRUE}
left_join(patients, hosp,
  by = c(
   "case_id" = "id_patient"))
```

]
.pull-right[

```{r, eval=TRUE, echo=FALSE}
left_join(patients,
          hosp_dup,
  by = c("case_id" = "id_patient")) %>% 
  qflextable() %>% 
  bg(part = "body", i = 1:2, j = 1:5, bg = "orange")
```

]

---

### Muitos para um

.pull-left[

```{r, eval=TRUE, echo=FALSE}

patients_dup <- tribble(
     ~case_id, ~age, ~age_unit, ~sex,
     "5fe599", 2, "years", "m",
     "5fe599", 2, "years", "m",
     "8689b7", 3, "years", "f",
     "11f8ea", 56, "years", "m",
     "b8812a", 18, "years", "f",
     "893f25", 3, "years", "m")


patients_dup %>% 
     qflextable() %>% 
     bg(part = "body", i = 1:2, j = 1:4, bg = "orange")
```

]
.pull-right[

```{r, eval=TRUE, echo=FALSE}

hosp %>%
    qflextable() %>% 
     bg(part = "body", i = 1, j = 1:2, bg = "orange")
```

]
.pull-left[

```{r, eval=FALSE, echo=TRUE}
left_join(patients, hosp,
  by = c(
   "case_id" = "id_patient"))
```

]
.pull-right[

```{r, eval=TRUE, echo=FALSE}
left_join(patients_dup,
          hosp,
  by = c("case_id" = "id_patient")) %>% 
  qflextable() %>% 
  bg(part = "body", i = 1:2, j = 1:5, bg = "orange")
```

]

---

# Boas práticas

Uso `semi_join()` e `anti_join()` para **entender por que as linhas são descartadas**

"Que `hosp` linhas não serão unidas à esquerda para `patients`?" Examine o motivo com `anti_join()`

```{r, eval=FALSE, echo=TRUE}
anti_join(hosp, patients, by = c("id_patient" = "case_id"))
```

```{r, eval=TRUE, echo=FALSE}
anti_join(hosp, patients, by = c("id_patient" = "case_id")) %>% 
     qflextable()
```

---

# Boas práticas

**Verifique as dimensões** dos quadros de dados antes e depois da mesclagem!\`

```{r, eval=TRUE, echo=TRUE}
nrow(patients)
```

```{r, eval=TRUE, echo=TRUE}
nrow(hosp)
```

```{r, eval=TRUE, echo=TRUE}
left_join(patients, hosp, by = c("case_id" = "id_patient")) %>%
  nrow()
```

???
Outra boa verificação é usar o `count()` para contar o número de linhas de cada um de seus identificadores.

---

class: inverse, center, middle

# Exercício!

Acesse o site do curso  
Abra o exercício do Módulo 8, parte 1, e faça login  
Siga as instruções para abrir o projeto R "ebola" e continue codificando o script RMD
Informe um instrutor se você não tiver certeza do que fazer

```{r, eval=TRUE, echo=FALSE, out.width="50%"}
# Using here() alone won't work because Rmd folder becomes the rendering root.
# adding xfun::relative_path() creates a dynamic file path between the Rmd location and the here() path.
# It dynamically creates the ../../etc filepath.

knitr::include_graphics(xfun::relative_path(here::here("images", "breakout", "window.png")))
```


